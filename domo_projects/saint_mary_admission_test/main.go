package main

import (
	"fmt"
	"github.com/leekchan/accounting"
	"math"
)

type Project struct {
	Name       string
	Upfront    float64
	ReturnRate float64
	CashFlow   []CashFlow
	Duration   int
	Income     float64
	NPV        float64
}

type CashFlow struct {
	Year        int
	Flow        string
	FlowFloat   float64
	Pv          float64
	Amount      string
	AmountFloat float64
}

func Calculation() {
	// Get the input
	var N int
	fmt.Printf("Enter the number of projects: ")
	_, _ = fmt.Scanln(&N)
	var projectList []*Project
	for i := 1; i <= N; i++ {
		pro := new(Project)
		fmt.Printf("\nEnter the name of the project: ")
		_, _ = fmt.Scanln(&pro.Name)
		fmt.Printf("Enter the upfront cost for the project %s: ", pro.Name)
		_, _ = fmt.Scanln(&pro.Upfront)
		fmt.Printf("Enter the rate of return or discount rate(in %%): ")
		_, _ = fmt.Scanln(&pro.ReturnRate)
		fmt.Printf("Enter the duration(in years): ")
		_, _ = fmt.Scanln(&pro.Duration)
		if pro.Duration <= 0 {
			fmt.Println("invalid duration !")
			return
		} else {
			flowList := make([]CashFlow, pro.Duration)
			for year := 1; year <= pro.Duration; year++ {
				var flow float64
				fmt.Printf("Enter the cash inflow-outflow during year %d:", year)
				_, _ = fmt.Scanln(&flow)
				flowList[year-1].Year = year
				ac := accounting.Accounting{Symbol: "$", Precision: 2}
				flowList[year-1].Flow = ac.FormatMoney(flow)
				flowList[year-1].FlowFloat = flow
				flowList[year-1].Pv = 1.0 / math.Pow(1+pro.ReturnRate/100, float64(year))
				flowList[year-1].Amount = ac.FormatMoney(flow * flowList[year-1].Pv)
				flowList[year-1].AmountFloat = flow * flowList[year-1].Pv
			}
			pro.CashFlow = append(pro.CashFlow, flowList...)
		}
		projectList = append(projectList, pro)
	}
	// Generate the output
	for _, project := range projectList {
		totalIncome := 0.0
		futureBenifit := 0.0
		fmt.Printf("\n                       %s\n", project.Name)
		fmt.Println("----------------------------------------------------------")
		fmt.Printf("%s\t%s%s%s\n", "Year", "|        Cash      ", "|   PV Factor  ", "|   Amount")
		fmt.Printf("%s\t%s%s\n", "    ", "|  Inflows/Outflows", "|")
		fmt.Println("----------------------------------------------------------")
		for _, cashFlow := range project.CashFlow {
			fmt.Printf("%d\t%s\t%.4f\t%s\n", cashFlow.Year, "|    "+cashFlow.Flow+"    |  ", cashFlow.Pv, "  |   "+cashFlow.Amount)
			totalIncome = totalIncome + cashFlow.FlowFloat
			futureBenifit = futureBenifit + cashFlow.AmountFloat
		}
		ac := accounting.Accounting{Symbol: "$", Precision: 2}
		fmt.Printf("Total Income: %s\n", ac.FormatMoney(totalIncome))
		fmt.Printf("Present Value of Future Benifits: %s\n", ac.FormatMoney(futureBenifit))
		fmt.Printf("Present Value of Future Costs: %s\n", ac.FormatMoney(project.Upfront))
		fmt.Printf("Net Present Value(NPV): %s\n", ac.FormatMoney(futureBenifit-project.Upfront))
		project.Income = totalIncome
		project.NPV = futureBenifit - project.Upfront
	}
	fmt.Printf("\nThe highest income is generated by project: %s\n", GetMaxIncome(projectList))
	fmt.Printf("The project the company should be executing is: %s\n", GetMaxNPV(projectList))
}

func GetMaxIncome(list []*Project) string {
	maxPro := &Project{
		Income: 0,
		NPV:    0,
	}
	for _, project := range list {
		if project.Income > maxPro.Income {
			maxPro = project
		} else if project.Income == maxPro.Income {
			if maxPro != nil && project.NPV > maxPro.NPV {
				maxPro = project
			}
		}
	}
	return maxPro.Name
}

func GetMaxNPV(list []*Project) string {
	maxPro := &Project{
		Income: 0,
		NPV:    0,
	}
	for _, project := range list {
		if project.NPV > maxPro.NPV {
			maxPro = project
		} else if project.NPV == maxPro.NPV {
			if maxPro != nil && project.Income > maxPro.Income {
				maxPro = project
			}
		}
	}
	return maxPro.Name
}

func main() {
	Calculation()
}
